# -*- coding: utf-8 -*-
"""
/***************************************************************************
 climaplotsDialog
                                 A QGIS plugin
 Climate Trend Data and Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-11-15
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Caio Arantes
        contact              : github.com/caioarantes
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *python
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import qgis

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtGui import QCursor, QPixmap
from qgis.PyQt.QtCore import Qt
from PyQt5.QtWidgets import QApplication
import sys 

# # Import libraries from extlibs
# import pymannkendall as mk
# import pyhomogeneity as hg


import importlib.util
import pandas as pd
import urllib.request, urllib.parse, urllib.error
import os, json, requests
import json
import ssl
import plotly.express as px
import io
from PyQt5.QtWidgets import QMainWindow, QLabel
from PyQt5.QtWidgets import QGridLayout, QWidget, QDesktopWidget
# from PyQt5.QtWebEngineWidgets import QWebEngineView
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import datetime

from PyQt5.QtWebKit import QWebSettings
QWebSettings.globalSettings().setAttribute(QWebSettings.WebGLEnabled, True)

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'clima_plots_dialog_base.ui'))

class climaplotsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(climaplotsDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.rejected.connect(self.fun_fechou)
        self.df = None
        self.gerar_req.clicked.connect(self.request_api)
        self.tabWidget.currentChanged.connect(self.tabChanged)
        self.atributo.currentTextChanged.connect(self.plots1)
        self.atributo_2.currentTextChanged.connect(self.plots3)
        self.dataframes_dict = None
        sheet_names = [
            'Total Annual Precipitation',
            'Annual Frost Days',
            'Annual Tropical Nights',
            'Annual Icing Days',
            'Annual Summer Days',
            'Monthly Maximum Temperature',
            'Monthly Minimum Temperature of Maximum Temperatures',
            'Monthly Maximum Temperature of Minimum Temperatures',
            'Monthly Minimum Temperature',
        #    'Daily Temperature Range',
            'Monthly Maximum 1-day Precipitation',
            'Monthly Maximum 5-day Precipitation',
            'Annual Count of Days when Precipitation Exceeds 10mm',
            'Annual Count of Days when Precipitation Exceeds 20mm',
            'Simple Precipitation Intensity Index',
            'Number of Consecutive Dry Days in a Month',
            'Number of Consecutive Wet Days in a Month',
            'The Standardized Precipitation Index (SPI)'
        ]
        for name in sheet_names:
            self.atributo_2.addItem(name)
        self.atributo_2.setCurrentIndex(0)

    def centralizar(self):
        qtRectangle = self.frameGeometry()
        centerPoint = QDesktopWidget().availableGeometry().center()
        qtRectangle.moveCenter(centerPoint)
        self.move(qtRectangle.topLeft())
        qtRectangle = self.frameGeometry()
        centerPoint = QDesktopWidget().availableGeometry().center()
        qtRectangle.moveCenter(centerPoint)
        self.move(qtRectangle.topLeft())

    def tamanho_inicial(self):
        self.resize(340, 170) # ver em .ui  
    def tamanho_grande(self):
        self.resize(1410, 680)
        self.centralizar()

    def tabChanged(self):
        if self.tabWidget.currentIndex() == 0: 
            self.tamanho_inicial()
        else:
            self.tamanho_grande()    

    def fun_fechou(self):
        self.LongEdit.clear()
        self.LatEdit.clear()
        self.tabWidget.setCurrentIndex(0)
        qgis.utils.iface.actionPan().trigger()

    def plots1(self):
        if self.LongEdit.text() == '' or self.df is None:
            return

        df =self.df
        atributo = self.atributo.currentText()
        df = df.reset_index().rename(columns={'index': 'Date'})
        df['Date'] =  pd.to_datetime(df['Date'])
        df_aux = df.groupby(df['Date'].dt.year)[['PRECTOTCORR']].sum()
        df = df.groupby(df['Date'].dt.year).mean()[['T2M_MIN','T2M_MAX']]
        df['PRECTOTCORR'] = df_aux['PRECTOTCORR']
        df.reset_index(inplace=True)
        df_aux = df[['Date', atributo]].copy()
        df_aux['Date'] = (df_aux['Date'].astype(str)+'-01-01').apply(pd.to_datetime)
        df_aux.index = df_aux['Date']
        df_aux = df_aux[[atributo]].astype(float)
        result_mk = mk.original_test(df_aux)
        result_pettitt = hg.pettitt_test(df_aux)

        title1 = 'Mann Kendall Test: trend=<b>'+result_mk.trend+'</b>, alpha=0.05'+', p-value='+str(round(result_mk.p, 4))
        title2 = None
        if result_pettitt.h:
            title2 = 'Pettitt Test: data is <b>nonhomogeneous</b>, probable change point location='+result_pettitt.cp[:4]+', alpha=0.05'+', p-value='+str(round(result_pettitt.p, 4))
        else:
            title2 = 'Pettitt Test: data is <b>homogeneous</b>, alpha=0.05'+', p-value='+str(round(result_pettitt.p, 4))

        title = title1+'<br>'+title2

        myFile = io.StringIO()
        fig = px.line(df, x="Date", y=[atributo], title='<b>'+atributo+'</b>  (Long: '+self.LongEdit.text() + ' Lat: '+self.LatEdit.text()+') <br>'+title)
        config = {'displaylogo': False,'modeBarButtonsToRemove': [
        "toImage",
        "sendDataToCloud",
        "zoom2d",
        "pan2d",
        "select2d",
        "lasso2d",
        "zoomIn2d",
        "zoomOut2d",
        "autoScale2d",
        "resetScale2d",
        "hoverClosestCartesian",
        "hoverCompareCartesian",
        "zoom3d",
        "pan3d",
        "orbitRotation",
        "tableRotation",
        "resetCameraLastSave",
        "resetCameraDefault3d",
        "hoverClosest3d",
        "zoomInGeo",
        "zoomOutGeo",
        "resetGeo",
        "hoverClosestGeo",
        "hoverClosestGl2d",
        "hoverClosestPie",
        "toggleHover",
        "toggleSpikelines",
        "resetViews"
        ]}
        fig.update_layout(showlegend=False)
        fig.write_html(myFile, config = config)
        html = myFile.getvalue()  
        self.webView_1.setHtml(html)
        print('ok plot1')

    def plots2(self):
        print('plot2 começou')
        if self.LongEdit.text() == '' or self.df is None:
            return
        df = self.df
        df = df.reset_index().rename(columns={'index': 'Date'})
        df['Date'] =  pd.to_datetime(df['Date'])
        df_aux = df.groupby([(df.Date.dt.year), (df.Date.dt.month)]).sum(numeric_only=True)[['PRECTOTCORR']]
        df = df.groupby([(df.Date.dt.year), (df.Date.dt.month)]).mean(numeric_only=True)[['T2M_MIN','T2M_MAX']]
        df['PRECTOTCORR'] = df_aux['PRECTOTCORR']
        df.reset_index(level=1, inplace=True)
        df = df.groupby(df.Date).mean()
        df.reset_index(inplace=True)
        df.rename(columns = {'Date':'Month'}, inplace = True)

        fig = make_subplots(specs=[[{"secondary_y": True}]])
        # Add traces
        fig.add_trace(
            go.Bar(x=df['Month'], y=df['PRECTOTCORR'], name='PRECTOTCORR'),
            secondary_y=False,
        )
        fig.add_trace(
            go.Line(x=df['Month'], y=df['T2M_MAX'], name='T2M_MAX'),
            secondary_y=True,
        )
        fig.update_layout(
            title_text="<b>Termopluviométrico</b>  (Long: "+self.LongEdit.text() + " Lat: "+self.LatEdit.text()+")"
        )

        # Set x-axis title
        fig.update_xaxes(title_text="Mês")

        fig.update_layout(
        xaxis = dict(
            tickmode = 'linear',
        )
        )

        # Set y-axes titles
        fig.update_yaxes(title_text="T2M_MAX (ºC)", secondary_y=True)
        fig.update_yaxes(title_text="PRECTOTCORR (mm)", secondary_y=False)

        myFile = io.StringIO()
        config = {'displaylogo': False,'modeBarButtonsToRemove': ['toImage','toggleHover']}
        fig.write_html(myFile, config = config)
        html = myFile.getvalue()  
        self.webView_4.setHtml(html)
        print('ok plot2')


    def plots3_compute(self):
        print('plot3 começou')
        if self.LongEdit.text() == '' or self.df is None:
            return
        df = self.df
        df = df.reset_index().rename(columns={'index': 'Date'})
        df['Date'] =  pd.to_datetime(df['Date'])
        df_aux = df.copy()       
        df.set_index('Date', inplace=True)
        ds = df[['PRECTOTCORR', 'T2M_MAX', 'T2M_MIN']].copy().to_xarray()

        precip_indices = pdex.indices(time_dim='Date')
        temp_indices = tdex.indices(time_dim='Date')

        # Temperature Indices using 'T2M_MAX' and 'T2M_MIN'
        frost_days_df = temp_indices.annual_frost_days(ds, varname='T2M_MIN').to_dataframe()
        frost_days_df.columns = ['Annual Frost Days']
        # frost_days_df.to_csv(name +' - '+ 'Annual Frost Days.csv')

        tropical_nights_df = temp_indices.annual_tropical_nights(ds, varname='T2M_MIN').to_dataframe()
        tropical_nights_df.columns = ['Annual Tropical Nights']
        # tropical_nights_df.to_csv(name +' - '+ 'Annual Tropical Nights.csv')

        icing_days_df = temp_indices.annual_icing_days(ds, varname='T2M_MAX').to_dataframe()
        icing_days_df.columns = ['Annual Icing Days']
        # icing_days_df.to_csv(name +' - '+ 'Annual Icing Days.csv')

        summer_days_df = temp_indices.annual_summer_days(ds, varname='T2M_MAX').to_dataframe()
        summer_days_df.columns = ['Annual Summer Days']
        # summer_days_df.to_csv(name +' - '+ 'Annual Summer Days.csv')

        txx_df = temp_indices.monthly_txx(ds, varname='T2M_MAX').to_dataframe()[['T2M_MAX']]
        txx_df.columns = ['Monthly Maximum Temperature']
        # txx_df.to_csv(name +' - '+ 'Monthly Maximum Temperature.csv')

        txn_df = temp_indices.monthly_txn(ds, varname='T2M_MAX').to_dataframe()[['T2M_MAX']]
        txn_df.columns = ['Monthly Minimum Temperature of Maximum Temperatures']
        # txn_df.to_csv(name +' - '+ 'Monthly Minimum Temperature of Maximum Temperatures.csv')

        tnx_df = temp_indices.monthly_tnx(ds, varname='T2M_MIN').to_dataframe()[['T2M_MIN']]
        tnx_df.columns = ['Monthly Maximum Temperature of Minimum Temperatures']
        # tnx_df.to_csv(name +' - '+ 'Monthly Maximum Temperature of Minimum Temperatures.csv')

        tnn_df = temp_indices.monthly_tnn(ds, varname='T2M_MIN').to_dataframe()[['T2M_MIN']]
        tnn_df.columns = ['Monthly Minimum Temperature']
        # tnn_df.to_csv(name +' - '+ 'Monthly Minimum Temperature.csv')

        dtr_df = temp_indices.daily_temperature_range(ds, ds, min_varname='T2M_MIN', max_varname='T2M_MAX').to_dataframe(name="DTR")
        dtr_df.columns = ['Daily Temperature Range']
        # dtr_df.to_csv(name +' - '+ 'Daily Temperature Range.csv')
        rx1day_df = precip_indices.monthly_rx1day(ds, varname='PRECTOTCORR').to_dataframe()
        rx1day_df.columns = ['Monthly Maximum 1-day Precipitation']
        # rx1day_df.to_csv(name +' - '+ 'Monthly Maximum 1-day Precipitation.csv')

        rx5day_df = precip_indices.monthly_rx5day(ds, varname='PRECTOTCORR').to_dataframe()
        rx5day_df.columns = ['Monthly Maximum 5-day Precipitation']
        # rx5day_df.to_csv(name +' - '+ 'Monthly Maximum 5-day Precipitation.csv')

        r10mm_df = precip_indices.annual_r10mm(ds, varname='PRECTOTCORR').to_dataframe()
        r10mm_df.columns = ['Annual Count of Days when Precipitation Exceeds 10mm']
        # r10mm_df.to_csv(name +' - '+ 'Annual Count of Days when Precipitation Exceeds 10mm.csv')

        r20mm_df = precip_indices.annual_r20mm(ds, varname='PRECTOTCORR').to_dataframe()
        r20mm_df.columns = ['Annual Count of Days when Precipitation Exceeds 20mm']
        # r20mm_df.to_csv(name +' - '+ 'Annual Count of Days when Precipitation Exceeds 20mm.csv')

        prcptot_annual_df = precip_indices.prcptot(ds, period='1Y', varname='PRECTOTCORR').to_dataframe()
        prcptot_annual_df.columns = ['Total Annual Precipitation']
        # prcptot_annual_df.to_csv(name +' - '+ 'Total Annual Precipitation.csv')

        sdii_value_df = precip_indices.sdii(ds, period='1M', varname='PRECTOTCORR').to_dataframe()
        sdii_value_df.columns = ['Simple Precipitation Intensity Index']
        # sdii_value_df.to_csv(name +' - '+ 'Simple Precipitation Intensity Index.csv')

        cdd_value_df = precip_indices.cdd(ds, period='1M', varname='PRECTOTCORR').to_dataframe()
        cdd_value_df.columns = ['Number of Consecutive Dry Days in a Month']
        # cdd_value_df.to_csv(name +' - '+ 'Number of Consecutive Dry Days in a Month.csv')

        cwd_value_df = precip_indices.cwd(ds, period='1M', varname='PRECTOTCORR').to_dataframe()
        cwd_value_df.columns = ['Number of Consecutive Wet Days in a Month']

        df_aux['Accumulated_Precipitation'] = df_aux['PRECTOTCORR'].rolling(window=90).sum()
        df_aux.dropna(inplace=True)
        params = gamma.fit(df_aux['Accumulated_Precipitation'], floc=0)
        df_aux['Cumulative_Probability'] = gamma.cdf(df_aux['Accumulated_Precipitation'], *params)
        # Transform the cumulative probabilities to the standard normal distribution to get the SPI values
        df_aux['SPI'] = norm.ppf(df_aux['Cumulative_Probability'])
        # Display the first few rows with the accumulated precipitation and SPI values
        spi_value_df = df_aux[['SPI']].copy()
        spi_value_df.columns = ['The Standardized Precipitation Index (SPI)']



        self.dataframes_dict = {
            'Annual Frost Days': frost_days_df,
            'Annual Tropical Nights': tropical_nights_df,
            'Annual Icing Days': icing_days_df,
            'Annual Summer Days': summer_days_df,
            'Monthly Maximum Temperature': txx_df,
            'Monthly Minimum Temperature of Maximum Temperatures': txn_df,
            'Monthly Maximum Temperature of Minimum Temperatures': tnx_df,
            'Monthly Minimum Temperature': tnn_df,
            'Daily Temperature Range': dtr_df,
            'Monthly Maximum 1-day Precipitation': rx1day_df,
            'Monthly Maximum 5-day Precipitation': rx5day_df,
            'Annual Count of Days when Precipitation Exceeds 10mm': r10mm_df,
            'Annual Count of Days when Precipitation Exceeds 20mm': r20mm_df,
            'Total Annual Precipitation': prcptot_annual_df,
            'Simple Precipitation Intensity Index': sdii_value_df,
            'Number of Consecutive Dry Days in a Month': cdd_value_df,
            'Number of Consecutive Wet Days in a Month': cwd_value_df,
            'The Standardized Precipitation Index (SPI)': spi_value_df,
        }
        print('ok plot3 compute')

    def plots3(self):
        print('plot3 começou')
        if self.atributo_2.currentText() == None or self.dataframes_dict is None:
            return
        df_plot = self.dataframes_dict[self.atributo_2.currentText()]
        print(self.atributo_2.currentText())
        myFile = io.StringIO()
        fig = px.line(df_plot, y=self.atributo_2.currentText(), title='<b>'+self.atributo_2.currentText()+'</b>  (Long: '+self.LongEdit.text() + ' Lat: '+self.LatEdit.text()+')')
        config = {'displaylogo': False,'modeBarButtonsToRemove': [
        "toImage",
        "sendDataToCloud",
        "zoom2d",
        "pan2d",
        "select2d",
        "lasso2d",
        "zoomIn2d",
        "zoomOut2d",
        "autoScale2d",
        "resetScale2d",
        "hoverClosestCartesian",
        "hoverCompareCartesian",
        "zoom3d",
        "pan3d",
        "orbitRotation",
        "tableRotation",
        "resetCameraLastSave",
        "resetCameraDefault3d",
        "hoverClosest3d",
        "zoomInGeo",
        "zoomOutGeo",
        "resetGeo",
        "hoverClosestGeo",
        "hoverClosestGl2d",
        "hoverClosestPie",
        "toggleHover",
        "toggleSpikelines",
        "resetViews"
        ]}
        fig.update_layout(showlegend=False)
        fig.write_html(myFile, config = config)
        html = myFile.getvalue()  
        self.webView_5.setHtml(html)
        print('ok plot3') 

    def actual_request_api(self):
        endtime = str(int(datetime.date.today().strftime("%Y"))-1)+'1231'
        base_url = (r"https://power.larc.nasa.gov/api/temporal/daily/point?parameters=T2M_MAX,PRECTOTCORR,T2M_MIN&community=RE&longitude={longitude}&latitude={latitude}&start=19810101&end="+endtime+"&format=JSON")
        api_request_url = base_url.format(longitude=float(self.LongEdit.text()), latitude = float(self.LatEdit.text()))
        response = requests.get(url=api_request_url, verify=True, timeout=1000)
        content = json.loads(response.content.decode('utf-8'))
        self.df = pd.DataFrame.from_dict(content['properties']['parameter'])
        self.reverse_geocode()
        print('ok request')       

    def reverse_geocode(self):
        base_url = (r"https://nominatim.openstreetmap.org/reverse?format=json&lat={latitude}&lon={longitude}&zoom=18&addressdetails=1")
        api_request_url = base_url.format(latitude=self.LatEdit.text(), longitude=self.LongEdit.text())
        response = requests.get(url=api_request_url, verify=True, timeout=1000)
        content = json.loads(response.content.decode('utf-8'))
        print(content['address']['city'])
        return

    def request_api(self):
        QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            self.actual_request_api()
            self.plots1()
            self.tabWidget.setCurrentIndex(1)
            self.plots2()
            self.plots3_compute()
            self.plots3()
        
            QApplication.restoreOverrideCursor()
        except Exception as e:
            print(f"An error occurred: {e}")
            QApplication.restoreOverrideCursor()

            