# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ClimaPlots Dialog
                                 A QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-24
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Caio Arantes
        email                : caiosimplicioarante@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

"""

# =============================================================================
# STANDARD LIBRARY IMPORTS
# =============================================================================
import os
import sys


# =============================================================================
# THIRD-PARTY IMPORTS
# =============================================================================

import pymannkendall as mk
import pyhomogeneity as hg
import climdex.precipitation as pdex
import climdex.temperature as tdex
import datetime
import xarray as xr
import numpy, scipy
import numpy as np
np.bool = np.bool_
from scipy.stats import gamma, norm
import importlib.util
import pandas as pd
import urllib.request, urllib.parse, urllib.error
import os, json, requests
import json
import ssl
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import io
import qgis

# =============================================================================
# QGIS IMPORTS
# =============================================================================

# QGIS Core imports
from qgis.core import (
    # Basic QGIS classes
    QgsMessageLog,
    Qgis,
    QgsWkbTypes,
    QgsProject,
    QgsApplication,
    
    # Vector handling
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsFeatureRequest,
    QgsFeature,
    QgsGeometry,
    QgsField,
    
    # Raster handling
    QgsRasterLayer,
    QgsRasterShader,
    QgsColorRampShader,
    QgsSingleBandPseudoColorRenderer,
    QgsMultiBandColorRenderer,
    QgsContrastEnhancement,
    QgsRasterBandStats,
    
    # Style and visualization
    QgsStyle,
    QgsColorRamp,
    QgsLayerTreeLayer,
    
    # Coordinate systems and geometry
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsRectangle,
    
    # Processing and feedback
    QgsProcessingFeedback,
    
    # Map layers
    QgsMapLayer,
)

# Qt GUI imports
from qgis.PyQt.QtGui import (
    QFont, 
    QColor
)

from qgis.PyQt.QtCore import (
    QDate, 
    Qt, 
    QVariant, 
    QSettings, 
    QTimer, 
    QEvent
)

from qgis.PyQt.QtWidgets import (
    # Application and main window
    QApplication,
    QMainWindow,
    QWidget,
    QDialog,
    
    # Layout managers
    QVBoxLayout,
    QHBoxLayout,
    QGridLayout,
    
    # Input widgets
    QCheckBox,
    QDateEdit,
    QPushButton,
    QToolButton,
    
    # Display widgets
    QLabel,
    QTextBrowser,
    QScrollArea,
    
    # Dialog components
    QMessageBox,
    QFileDialog,
    QDialogButtonBox,
    
    # Size policies
    QSizePolicy,
)

from qgis.PyQt import uic


# =============================================================================
# LOCAL MODULE IMPORTS
# =============================================================================

from .modules import (
    map_tools,
    save_utils,
)
# =============================================================================
# UI CONFIGURATION
# =============================================================================

# Load the UI file for the main dialog
ui_file = os.path.join("ui", "climaplots_dialog_base.ui")
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), ui_file))

# =============================================================================
# MAIN DIALOG CLASS
# =============================================================================

class ClimaPlotsDialog(QDialog, FORM_CLASS):
    """
    Main dialog class for ClimaPlots plugin.
    
    Attributes:
        iface: QGIS interface object
        focus_timer: Timer for managing window focus
        Various data processing attributes (aoi, df, collection, etc.)
    """
    
    def __init__(self, parent=None, iface=None):
        """
        Initialize the ClimaPlots dialog.
        
        Args:
            parent: Parent widget (default: None)
            iface: QGIS interface object (default: None)
        """
        super(ClimaPlotsDialog, self).__init__(parent)
        self.setupUi(self)
        self.iface = iface
        
        # Configure window properties
        self.setWindowFlags(
            Qt.WindowType.Window |
            Qt.WindowType.WindowCloseButtonHint |
            Qt.WindowType.WindowMinimizeButtonHint |
            Qt.WindowType.WindowMaximizeButtonHint
        )
        self.setModal(False)
        
        # Initialize focus management timer
        self.focus_timer = QTimer()
        self.focus_timer.timeout.connect(self.check_focus)

        # Initialize window size
        QTimer.singleShot(0, lambda: self.resizeEvent("small"))

        self.config = {
            "displaylogo": False,
            "modeBarButtonsToRemove": [
                "toImage",
                "sendDataToCloud",
                "zoom2d",
                "pan2d",
                "select2d",
                "lasso2d",
                "zoomIn2d",
                "zoomOut2d",
                "autoScale2d",
                "resetScale2d",
                "hoverClosestCartesian",
                "hoverCompareCartesian",
                "zoom3d",
                "pan3d",
                "orbitRotation",
                "tableRotation",
                "resetCameraLastSave",
                "resetCameraDefault3d",
                "hoverClosest3d",
                "zoomInGeo",
                "zoomOutGeo",
                "resetGeo",
                "hoverClosestGeo",
                "hoverClosestGl2d",
                "hoverClosestPie",
                "toggleHover",
                "toggleSpikelines",
                "resetViews",
            ],
        }

        self.tabWidget.currentChanged.connect(self.on_tab_changed)
        self.navegador.clicked.connect(self.on_navegador_clicked)
        self.navegador_2.clicked.connect(self.on_navegador_clicked_2)
        self.navegador_3.clicked.connect(self.on_navegador_clicked_3)
        self.save_plot.clicked.connect(self.save_clicked)
        self.save_plot2.clicked.connect(self.save_clicked2)
        self.save_plot3.clicked.connect(self.save_clicked3)
        self.save_raw.clicked.connect(self.save_raw_clicked)

        self.rejected.connect(self.fun_fechou)
        self.df = None
        self.gerar_req.clicked.connect(self.request_api)
        self.atributo.currentTextChanged.connect(self.plots1)
        self.atributo_2.currentTextChanged.connect(self.plots3)
        self.googlemaps.clicked.connect(map_tools.hybrid_function)
        self.dataframes_dict = None
        sheet_names = [
            'Total Annual Precipitation',
            'Annual Frost Days',
            'Annual Tropical Nights',
            'Annual Icing Days',
            'Annual Summer Days',
            'Monthly Maximum Temperature',
            'Monthly Minimum Temperature of Maximum Temperatures',
            'Monthly Maximum Temperature of Minimum Temperatures',
            'Monthly Minimum Temperature',
            'Daily Temperature Range',
            'Monthly Maximum 1-day Precipitation',
            'Monthly Maximum 5-day Precipitation',
            'Annual Count of Days when Precipitation Exceeds 10mm',
            'Annual Count of Days when Precipitation Exceeds 20mm',
            'Simple Precipitation Intensity Index',
            'Number of Consecutive Dry Days in a Month',
            'Number of Consecutive Wet Days in a Month',
            'The Standardized Precipitation Index (SPI)'
        ]
        for name in sheet_names:
            self.atributo_2.addItem(name)
        self.atributo_2.setCurrentIndex(0)
        self.tabWidget.setCurrentIndex(0)

    
    def showEvent(self, event):
        """
        Handle dialog show event.
        
        Starts the focus timer and ensures proper window sizing.
        
        Args:
            event: The show event object
        """
        super().showEvent(event)
        
        # Ensure window size is locked when first shown
        if not hasattr(self, '_size_locked'):
            self.resizeEvent("small")
            self._size_locked = True
            
        # Start focus management timer
        if hasattr(self, 'focus_timer'):
            self.focus_timer.start(100)

    def hideEvent(self, event):
        """
        Handle dialog hide event.
        
        Stops the focus timer to prevent unnecessary processing.
        
        Args:
            event: The hide event object
        """
        super().hideEvent(event)
        if hasattr(self, 'focus_timer'):
            try:
                self.focus_timer.stop()
            except RuntimeError:
                # Timer might already be stopped or deleted
                pass

    def check_focus(self):
        """
        Check if the plugin window should be brought to front.
        
        This method implements a less aggressive focus management strategy
        that only raises the window when appropriate, avoiding interference
        with internal QGIS events.
        """
        if not self.isVisible() or self.isMinimized():
            return
            
        # Only act when clicking on map canvas specifically
        active_window = QApplication.activeWindow()
        if (active_window == self.iface.mainWindow() and 
            not QApplication.activeModalWidget() and
            not self.isActiveWindow()):
            
            # Only raise window, don't activate to avoid event interference
            self.raise_()

    def closeEvent(self, event):


        """
        Handle dialog close event.
        
        Instead of actually closing the dialog, this method hides it to
        preserve the current state and settings. This allows the user
        to reopen the dialog with all their previous work intact.
        
        Args:
            event: The close event object
        """
        # Stop the focus timer to prevent memory leaks
        if hasattr(self, 'focus_timer'):
            try:
                self.focus_timer.stop()
            except RuntimeError:
                # Timer might already be stopped
                pass
        
        # Hide the dialog instead of closing to preserve state
        self.hide()
        event.ignore()

    def on_tab_changed(self, index):
        """
        Handle tab change events.
        
        """
        print(f"Tab changed to index: {index}")
        if index != 0:
            self.resizeEvent("big")
        else:
            self.resizeEvent("small")

    def resizeEvent(self, event):

        self.setMinimumSize(0, 0)  # Remove minimum size constraint
        self.setMaximumSize(16777215, 16777215)  # Remove maximum size constraint

        if event == "small":
            self.resize(405,180)
            self.setFixedSize(self.width(), self.height())  # Lock to small size
        elif event == "big":
            self.resize(945, 535)
            self.setFixedSize(self.width(), self.height())  # Lock to big size

    def fun_fechou(self):
        self.LongEdit.clear()
        self.LatEdit.clear()
        self.tabWidget.setCurrentIndex(0)
        qgis.utils.iface.actionPan().trigger()

    def save_clicked(self):
        name = (
            f"Anual_trends_{self.atributo.currentText()}.csv"
        )
        save_utils.save(self.df_save, name, self)

    def save_clicked2(self):
        name = (
            f"Thermopluviometric.csv"
        )
        save_utils.save(self.df_save2, name, self)

    def save_clicked3(self):
        name = (
            f"{self.atributo_2.currentText()}.csv"
        )
        save_utils.save(self.df_save3, name, self)

    def save_raw_clicked(self):
        name = (
            f"Raw_data.csv"
        )
        save_utils.save(self.df, name, self)

    def on_navegador_clicked(self):
        self.fig.show()

    def on_navegador_clicked_2(self):
        self.fig2.show()

    def on_navegador_clicked_3(self):
        self.fig3.show()

    def plots1(self):
        if self.df is None:
            return
        atributo = self.atributo.currentText()
        df = self.df.copy()
        # Agrupa por ano corretamente e usa a coluna 'Date' como index
        df['Year'] = df['Date'].dt.year
        df_aux = df.groupby('Year')[['Precipitation']].sum()
        df_mean = df.groupby('Year').mean()[['Min Temperature','Max Temperature']]
        df_mean['Precipitation'] = df_aux['Precipitation']
        df_mean.reset_index(inplace=True)
        # Cria coluna 'Date' para o início de cada ano
        df_mean['Date'] = pd.to_datetime(df_mean['Year'].astype(str) + '-01-01')
        df_plot = df_mean[['Date', atributo]].copy()
        df_plot.index = df_plot['Date']
        df_plot = df_plot[[atributo]].astype(float)
        result_mk = mk.original_test(df_plot)
        result_pettitt = hg.pettitt_test(df_plot)

        title1 = 'Mann Kendall Test: trend=<b>'+result_mk.trend+'</b>, alpha=0.05'+', p-value='+str(round(result_mk.p, 4))
        title2 = None
        if result_pettitt.h:
            title2 = 'Pettitt Test: data is <b>nonhomogeneous</b>, probable change point location='+str(result_pettitt.cp)[:4]+', alpha=0.05'+', p-value='+str(round(result_pettitt.p, 4))
        else:
            title2 = 'Pettitt Test: data is <b>homogeneous</b>, alpha=0.05'+', p-value='+str(round(result_pettitt.p, 4))

        title = title1+'<br>'+title2

        self.fig = px.line(df_mean, x="Date", y=[atributo], title='<b>'+atributo+'</b>  (Long: '+self.LongEdit.text() + ' Lat: '+self.LatEdit.text()+') <br>'+title)

        self.fig.update_layout(showlegend=False)

        if atributo == "Precipitation":
            self.fig.update_yaxes(title_text="Precipitation (mm) - Annual Total")
        if atributo == "Min Temperature":
            self.fig.update_yaxes(title_text="Min Temperature (ºC)")
        if atributo == "Max Temperature":
            self.fig.update_yaxes(title_text="Max Temperature (ºC)")

        self.webView_1.setHtml(
            self.fig.to_html(include_plotlyjs="cdn", config=self.config)
        )
        print('ok plot1')

        self.df_save = df_mean

    def plots2(self):
        if self.df is None:
            return
        print('plot2 começou')

        df = self.df.copy()
        df_aux = df.groupby([(df.Date.dt.year), (df.Date.dt.month)]).sum(numeric_only=True)[['Precipitation']]
        df = df.groupby([(df.Date.dt.year), (df.Date.dt.month)]).mean(numeric_only=True)[['Min Temperature','Max Temperature']]
        df['Precipitation'] = df_aux['Precipitation']
        df.reset_index(level=1, inplace=True)
        df = df.groupby(df.Date).mean()
        df.reset_index(inplace=True)
        df.rename(columns = {'Date':'Month'}, inplace = True)

        self.fig2 = make_subplots(specs=[[{"secondary_y": True}]])
        # Add traces
        self.fig2.add_trace(
            go.Bar(x=df['Month'], y=df['Precipitation'], name='Precipitation'),
            secondary_y=False,
        )
        self.fig2.add_trace(
            go.Line(x=df['Month'], y=df['Max Temperature'], name='Max Temperature'),
            secondary_y=True,
        )
        self.fig2.update_layout(
            title_text="<b>Thermo-pluviometric diagram</b>  (Long: "+self.LongEdit.text() + " Lat: "+self.LatEdit.text()+")"
        )

        # Set x-axis title
        self.fig2.update_xaxes(title_text="Month")

        self.fig2.update_layout(
        xaxis = dict(
            tickmode = 'linear',
        )
        )

        # Set y-axes titles
        self.fig2.update_yaxes(title_text="Max Temperature (ºC)", secondary_y=True)
        self.fig2.update_yaxes(title_text="Precipitation (mm)", secondary_y=False)

        self.webView_2.setHtml(
            self.fig2.to_html(include_plotlyjs="cdn", config=self.config)
        )
        print('ok plot2')

        self.df_save2 = df

    def plots3_compute(self):
        if self.df is None:
            return
        print('plot3 compute começou')
        df = self.df.copy()
        df_aux = df.copy()       
        df.set_index('Date', inplace=True)
        ds = df[['Precipitation', 'Max Temperature', 'Min Temperature']].copy().to_xarray()

        precip_indices = pdex.indices(time_dim='Date')
        temp_indices = tdex.indices(time_dim='Date')

        # Temperature Indices using 'Max Temperature' and 'Min Temperature'
        frost_days_df = temp_indices.annual_frost_days(ds, varname='Min Temperature').to_dataframe()
        frost_days_df.columns = ['Annual Frost Days']
        # frost_days_df.to_csv(name +' - '+ 'Annual Frost Days.csv')

        tropical_nights_df = temp_indices.annual_tropical_nights(ds, varname='Min Temperature').to_dataframe()
        tropical_nights_df.columns = ['Annual Tropical Nights']
        # tropical_nights_df.to_csv(name +' - '+ 'Annual Tropical Nights.csv')

        icing_days_df = temp_indices.annual_icing_days(ds, varname='Max Temperature').to_dataframe()
        icing_days_df.columns = ['Annual Icing Days']
        # icing_days_df.to_csv(name +' - '+ 'Annual Icing Days.csv')

        summer_days_df = temp_indices.annual_summer_days(ds, varname='Max Temperature').to_dataframe()
        summer_days_df.columns = ['Annual Summer Days']
        # summer_days_df.to_csv(name +' - '+ 'Annual Summer Days.csv')

        txx_df = temp_indices.monthly_txx(ds, varname='Max Temperature').to_dataframe()[['Max Temperature']]
        txx_df.columns = ['Monthly Maximum Temperature']
        # txx_df.to_csv(name +' - '+ 'Monthly Maximum Temperature.csv')

        txn_df = temp_indices.monthly_txn(ds, varname='Max Temperature').to_dataframe()[['Max Temperature']]
        txn_df.columns = ['Monthly Minimum Temperature of Maximum Temperatures']
        # txn_df.to_csv(name +' - '+ 'Monthly Minimum Temperature of Maximum Temperatures.csv')

        tnx_df = temp_indices.monthly_tnx(ds, varname='Min Temperature').to_dataframe()[['Min Temperature']]
        tnx_df.columns = ['Monthly Maximum Temperature of Minimum Temperatures']
        # tnx_df.to_csv(name +' - '+ 'Monthly Maximum Temperature of Minimum Temperatures.csv')

        tnn_df = temp_indices.monthly_tnn(ds, varname='Min Temperature').to_dataframe()[['Min Temperature']]
        tnn_df.columns = ['Monthly Minimum Temperature']
        # tnn_df.to_csv(name +' - '+ 'Monthly Minimum Temperature.csv')

        dtr_df = temp_indices.daily_temperature_range(ds, ds, min_varname='Min Temperature', max_varname='Max Temperature').to_dataframe(name="DTR")
        dtr_df.columns = ['Daily Temperature Range']
        # dtr_df.to_csv(name +' - '+ 'Daily Temperature Range.csv')
        rx1day_df = precip_indices.monthly_rx1day(ds, varname='Precipitation').to_dataframe()
        rx1day_df.columns = ['Monthly Maximum 1-day Precipitation']
        # rx1day_df.to_csv(name +' - '+ 'Monthly Maximum 1-day Precipitation.csv')

        rx5day_df = precip_indices.monthly_rx5day(ds, varname='Precipitation').to_dataframe()
        rx5day_df.columns = ['Monthly Maximum 5-day Precipitation']
        # rx5day_df.to_csv(name +' - '+ 'Monthly Maximum 5-day Precipitation.csv')

        r10mm_df = precip_indices.annual_r10mm(ds, varname='Precipitation').to_dataframe()
        r10mm_df.columns = ['Annual Count of Days when Precipitation Exceeds 10mm']
        # r10mm_df.to_csv(name +' - '+ 'Annual Count of Days when Precipitation Exceeds 10mm.csv')

        r20mm_df = precip_indices.annual_r20mm(ds, varname='Precipitation').to_dataframe()
        r20mm_df.columns = ['Annual Count of Days when Precipitation Exceeds 20mm']
        # r20mm_df.to_csv(name +' - '+ 'Annual Count of Days when Precipitation Exceeds 20mm.csv')

        prcptot_annual_df = precip_indices.prcptot(ds, period='1Y', varname='Precipitation').to_dataframe()
        prcptot_annual_df.columns = ['Total Annual Precipitation']
        # prcptot_annual_df.to_csv(name +' - '+ 'Total Annual Precipitation.csv')

        sdii_value_df = precip_indices.sdii(ds, period='1M', varname='Precipitation').to_dataframe()
        sdii_value_df.columns = ['Simple Precipitation Intensity Index']
        # sdii_value_df.to_csv(name +' - '+ 'Simple Precipitation Intensity Index.csv')

        cdd_value_df = precip_indices.cdd(ds, period='1M', varname='Precipitation').to_dataframe()
        cdd_value_df.columns = ['Number of Consecutive Dry Days in a Month']
        # cdd_value_df.to_csv(name +' - '+ 'Number of Consecutive Dry Days in a Month.csv')

        cwd_value_df = precip_indices.cwd(ds, period='1M', varname='Precipitation').to_dataframe()
        cwd_value_df.columns = ['Number of Consecutive Wet Days in a Month']

        df_aux['Accumulated_Precipitation'] = df_aux['Precipitation'].rolling(window=90).sum()
        df_aux.dropna(inplace=True)
        params = gamma.fit(df_aux['Accumulated_Precipitation'], floc=0)
        df_aux['Cumulative_Probability'] = gamma.cdf(df_aux['Accumulated_Precipitation'], *params)
        # Transform the cumulative probabilities to the standard normal distribution to get the SPI values
        df_aux['SPI'] = norm.ppf(df_aux['Cumulative_Probability'])
        # Display the first few rows with the accumulated precipitation and SPI values
        spi_value_df = df_aux[['SPI']].copy()
        spi_value_df.columns = ['The Standardized Precipitation Index (SPI)']

        print('ok plot3 compute')

        self.dataframes_dict = {
            'Annual Frost Days': frost_days_df,
            'Annual Tropical Nights': tropical_nights_df,
            'Annual Icing Days': icing_days_df,
            'Annual Summer Days': summer_days_df,
            'Monthly Maximum Temperature': txx_df,
            'Monthly Minimum Temperature of Maximum Temperatures': txn_df,
            'Monthly Maximum Temperature of Minimum Temperatures': tnx_df,
            'Monthly Minimum Temperature': tnn_df,
            'Daily Temperature Range': dtr_df,
            'Monthly Maximum 1-day Precipitation': rx1day_df,
            'Monthly Maximum 5-day Precipitation': rx5day_df,
            'Annual Count of Days when Precipitation Exceeds 10mm': r10mm_df,
            'Annual Count of Days when Precipitation Exceeds 20mm': r20mm_df,
            'Total Annual Precipitation': prcptot_annual_df,
            'Simple Precipitation Intensity Index': sdii_value_df,
            'Number of Consecutive Dry Days in a Month': cdd_value_df,
            'Number of Consecutive Wet Days in a Month': cwd_value_df,
            'The Standardized Precipitation Index (SPI)': spi_value_df,
        }
        print('ok plot3 compute')

    def plots3(self):
        if self.df is None:
            return
        print('plot3 começou')
        df_plot = self.dataframes_dict[self.atributo_2.currentText()]
        print(self.atributo_2.currentText())
        self.fig3 = px.line(df_plot, y=self.atributo_2.currentText(), title='<b>'+self.atributo_2.currentText()+'</b>  (Long: '+self.LongEdit.text() + ' Lat: '+self.LatEdit.text()+')')
        self.fig3.update_layout(showlegend=False)
        self.webView_3.setHtml(
            self.fig3.to_html(include_plotlyjs="cdn", config=self.config)
        )
        # Adiciona coluna 'Year' ao DataFrame
        if 'Date' in df_plot.columns:
            df_plot['Year'] = pd.to_datetime(df_plot['Date']).dt.year
        elif df_plot.index.name == 'Date':
            df_plot['Year'] = pd.to_datetime(df_plot.index).year
        self.df_save3 = df_plot
        print('ok plot3')

    def actual_request_api(self):
        endtime = str(int(datetime.date.today().strftime("%Y"))-1)+'1231'
        base_url = (r"https://power.larc.nasa.gov/api/temporal/daily/point?parameters=T2M_MAX,PRECTOTCORR,T2M_MIN&community=RE&longitude={longitude}&latitude={latitude}&start=19810101&end="+endtime+"&format=JSON")
        api_request_url = base_url.format(longitude=float(self.LongEdit.text()), latitude = float(self.LatEdit.text()))
        response = requests.get(url=api_request_url, verify=True, timeout=1000)
        content = json.loads(response.content.decode('utf-8'))
        df = pd.DataFrame.from_dict(content['properties']['parameter'])
        df = df.reset_index().rename(columns={'index': 'Date', 'PRECTOTCORR': 'Precipitation', 'T2M_MIN': 'Min Temperature', 'T2M_MAX': 'Max Temperature'})
        df.Date = pd.to_datetime(df.Date)
        print('ok request') 
        print(df.head())
        return df      

    def request_api(self):
        QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            self.df = self.actual_request_api()
            self.plots1()
            self.plots2()
            self.plots3_compute()
            self.plots3()
            self.tabWidget.setCurrentIndex(1)            
        except Exception as e:
            print(f"An error occurred: {e}")
        finally:
            QApplication.restoreOverrideCursor()