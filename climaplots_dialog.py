# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ClimaPlots Dialog
                                 A QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-24
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Caio Arantes
        email                : caiosimplicioarante@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

"""

# =============================================================================
# STANDARD LIBRARY IMPORTS
# =============================================================================
import os
import sys


# =============================================================================
# THIRD-PARTY IMPORTS
# =============================================================================

import pymannkendall as mk
import pyhomogeneity as hg
import climdex.precipitation as pdex
import climdex.temperature as tdex
import datetime
import xarray as xr
import numpy, scipy
import numpy as np
np.bool = np.bool_
from scipy.stats import gamma, norm
import importlib.util
import pandas as pd
import urllib.request, urllib.parse, urllib.error
import os, json, requests
import json
import ssl
import plotly.express as px
import io
import qgis

# =============================================================================
# QGIS IMPORTS
# =============================================================================

# QGIS Core imports
from qgis.core import (
    # Basic QGIS classes
    QgsMessageLog,
    Qgis,
    QgsWkbTypes,
    QgsProject,
    QgsApplication,
    
    # Vector handling
    QgsVectorLayer,
    QgsVectorFileWriter,
    QgsFeatureRequest,
    QgsFeature,
    QgsGeometry,
    QgsField,
    
    # Raster handling
    QgsRasterLayer,
    QgsRasterShader,
    QgsColorRampShader,
    QgsSingleBandPseudoColorRenderer,
    QgsMultiBandColorRenderer,
    QgsContrastEnhancement,
    QgsRasterBandStats,
    
    # Style and visualization
    QgsStyle,
    QgsColorRamp,
    QgsLayerTreeLayer,
    
    # Coordinate systems and geometry
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsRectangle,
    
    # Processing and feedback
    QgsProcessingFeedback,
    
    # Map layers
    QgsMapLayer,
)

# Qt GUI imports
from qgis.PyQt.QtGui import (
    QFont, 
    QColor
)

from qgis.PyQt.QtCore import (
    QDate, 
    Qt, 
    QVariant, 
    QSettings, 
    QTimer, 
    QEvent
)

from qgis.PyQt.QtWidgets import (
    # Application and main window
    QApplication,
    QMainWindow,
    QWidget,
    QDialog,
    
    # Layout managers
    QVBoxLayout,
    QHBoxLayout,
    QGridLayout,
    
    # Input widgets
    QCheckBox,
    QDateEdit,
    QPushButton,
    QToolButton,
    
    # Display widgets
    QLabel,
    QTextBrowser,
    QScrollArea,
    
    # Dialog components
    QMessageBox,
    QFileDialog,
    QDialogButtonBox,
    
    # Size policies
    QSizePolicy,
)

from qgis.PyQt import uic


# =============================================================================
# LOCAL MODULE IMPORTS
# =============================================================================

from .modules import (
    map_tools
)
# =============================================================================
# UI CONFIGURATION
# =============================================================================

# Load the UI file for the main dialog
ui_file = os.path.join("ui", "climaplots_dialog_base.ui")
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), ui_file))


# =============================================================================
# MAIN DIALOG CLASS
# =============================================================================

class ClimaPlotsDialog(QDialog, FORM_CLASS):
    """
    Main dialog class for ClimaPlots plugin.
    
    This class provides a graphical interface for Sentinel-1 SAR Backscatter 
    Analysis Ready Data Preparation using Google Earth Engine. It simplifies
    the process of configuring and running Sentinel-1 SAR data processing
    without requiring manual coding.
    
    Attributes:
        iface: QGIS interface object
        focus_timer: Timer for managing window focus
        Various data processing attributes (aoi, df, collection, etc.)
    """
    
    def __init__(self, parent=None, iface=None):
        """
        Initialize the ClimaPlots dialog.
        
        Args:
            parent: Parent widget (default: None)
            iface: QGIS interface object (default: None)
        """
        super(ClimaPlotsDialog, self).__init__(parent)
        self.setupUi(self)
        self.iface = iface
        
        # Configure window properties
        self.setWindowFlags(
            Qt.WindowType.Window |
            Qt.WindowType.WindowCloseButtonHint |
            Qt.WindowType.WindowMinimizeButtonHint |
            Qt.WindowType.WindowMaximizeButtonHint
        )
        self.setModal(False)
        
        # Initialize focus management timer
        self.focus_timer = QTimer()
        self.focus_timer.timeout.connect(self.check_focus)

        # Initialize window size
        QTimer.singleShot(0, lambda: self.resizeEvent("small"))

        self.tabWidget.currentChanged.connect(self.on_tab_changed)

    # =========================================================================
    # WINDOW EVENT HANDLERS
    # =========================================================================
    
    def showEvent(self, event):
        """
        Handle dialog show event.
        
        Starts the focus timer and ensures proper window sizing.
        
        Args:
            event: The show event object
        """
        super().showEvent(event)
        
        # Ensure window size is locked when first shown
        if not hasattr(self, '_size_locked'):
            self.resizeEvent("small")
            self._size_locked = True
            
        # Start focus management timer
        if hasattr(self, 'focus_timer'):
            self.focus_timer.start(100)

    def hideEvent(self, event):
        """
        Handle dialog hide event.
        
        Stops the focus timer to prevent unnecessary processing.
        
        Args:
            event: The hide event object
        """
        super().hideEvent(event)
        if hasattr(self, 'focus_timer'):
            try:
                self.focus_timer.stop()
            except RuntimeError:
                # Timer might already be stopped or deleted
                pass

    def check_focus(self):
        """
        Check if the plugin window should be brought to front.
        
        This method implements a less aggressive focus management strategy
        that only raises the window when appropriate, avoiding interference
        with internal QGIS events.
        """
        if not self.isVisible() or self.isMinimized():
            return
            
        # Only act when clicking on map canvas specifically
        active_window = QApplication.activeWindow()
        if (active_window == self.iface.mainWindow() and 
            not QApplication.activeModalWidget() and
            not self.isActiveWindow()):
            
            # Only raise window, don't activate to avoid event interference
            self.raise_()

    def closeEvent(self, event):


        """
        Handle dialog close event.
        
        Instead of actually closing the dialog, this method hides it to
        preserve the current state and settings. This allows the user
        to reopen the dialog with all their previous work intact.
        
        Args:
            event: The close event object
        """
        # Stop the focus timer to prevent memory leaks
        if hasattr(self, 'focus_timer'):
            try:
                self.focus_timer.stop()
            except RuntimeError:
                # Timer might already be stopped
                pass
        
        # Hide the dialog instead of closing to preserve state
        self.hide()
        event.ignore()

    def on_tab_changed(self, index):
        """
        Handle tab change events.
        
        """
        print(f"Tab changed to index: {index}")
        if index != 0:
            self.resizeEvent("big")
        else:
            self.resizeEvent("small")


    def resizeEvent(self, event):

        self.setMinimumSize(0, 0)  # Remove minimum size constraint
        self.setMaximumSize(16777215, 16777215)  # Remove maximum size constraint

        if event == "small":
            self.resize(405,180)
            self.setFixedSize(self.width(), self.height())  # Lock to small size
        elif event == "big":
            self.resize(945, 535)
            self.setFixedSize(self.width(), self.height())  # Lock to big size


        #self.setupUi(self)
        self.rejected.connect(self.fun_fechou)
        #self.tamanho_inicial()
        self.df = None
        self.gerar_req.clicked.connect(self.request_api)
        #self.tabWidget.currentChanged.connect(self.tabChanged)
        self.atributo.currentTextChanged.connect(self.plots1)
        self.atributo_2.currentTextChanged.connect(self.plots3)
        self.googlemaps.clicked.connect(map_tools.hybrid_function)
        self.dataframes_dict = None
        sheet_names = [
            'Total Annual Precipitation',
            'Annual Frost Days',
            'Annual Tropical Nights',
            'Annual Icing Days',
            'Annual Summer Days',
            'Monthly Maximum Temperature',
            'Monthly Minimum Temperature of Maximum Temperatures',
            'Monthly Maximum Temperature of Minimum Temperatures',
            'Monthly Minimum Temperature',
        #    'Daily Temperature Range',
            'Monthly Maximum 1-day Precipitation',
            'Monthly Maximum 5-day Precipitation',
            'Annual Count of Days when Precipitation Exceeds 10mm',
            'Annual Count of Days when Precipitation Exceeds 20mm',
            'Simple Precipitation Intensity Index',
            'Number of Consecutive Dry Days in a Month',
            'Number of Consecutive Wet Days in a Month',
            'The Standardized Precipitation Index (SPI)'
        ]
        for name in sheet_names:
            self.atributo_2.addItem(name)
        self.atributo_2.setCurrentIndex(0)


    def fun_fechou(self):
        self.LongEdit.clear()
        self.LatEdit.clear()
        self.tabWidget.setCurrentIndex(0)
        qgis.utils.iface.actionPan().trigger()

    def plots1(self):
        if self.LongEdit.text() == '' or self.df is None:
            return

        df =self.df
        atributo = self.atributo.currentText()
        df = df.reset_index().rename(columns={'index': 'Date'})
        df['Date'] =  pd.to_datetime(df['Date'])
        df_aux = df.groupby(df['Date'].dt.year)[['PRECTOTCORR']].sum()
        df = df.groupby(df['Date'].dt.year).mean()[['T2M_MIN','T2M_MAX']]
        df['PRECTOTCORR'] = df_aux['PRECTOTCORR']
        df.reset_index(inplace=True)
        df_aux = df[['Date', atributo]].copy()
        df_aux['Date'] = (df_aux['Date'].astype(str)+'-01-01').apply(pd.to_datetime)
        df_aux.index = df_aux['Date']
        df_aux = df_aux[[atributo]].astype(float)
        result_mk = mk.original_test(df_aux)
        result_pettitt = hg.pettitt_test(df_aux)

        title1 = 'Mann Kendall Test: trend=<b>'+result_mk.trend+'</b>, alpha=0.05'+', p-value='+str(round(result_mk.p, 4))
        title2 = None
        if result_pettitt.h:
            title2 = 'Pettitt Test: data is <b>nonhomogeneous</b>, probable change point location='+result_pettitt.cp[:4]+', alpha=0.05'+', p-value='+str(round(result_pettitt.p, 4))
        else:
            title2 = 'Pettitt Test: data is <b>homogeneous</b>, alpha=0.05'+', p-value='+str(round(result_pettitt.p, 4))

        title = title1+'<br>'+title2

        myFile = io.StringIO()
        fig = px.line(df, x="Date", y=[atributo], title='<b>'+atributo+'</b>  (Long: '+self.LongEdit.text() + ' Lat: '+self.LatEdit.text()+') <br>'+title)
        config = {'displaylogo': False,'modeBarButtonsToRemove': [
        "toImage",
        "sendDataToCloud",
        "zoom2d",
        "pan2d",
        "select2d",
        "lasso2d",
        "zoomIn2d",
        "zoomOut2d",
        "autoScale2d",
        "resetScale2d",
        "hoverClosestCartesian",
        "hoverCompareCartesian",
        "zoom3d",
        "pan3d",
        "orbitRotation",
        "tableRotation",
        "resetCameraLastSave",
        "resetCameraDefault3d",
        "hoverClosest3d",
        "zoomInGeo",
        "zoomOutGeo",
        "resetGeo",
        "hoverClosestGeo",
        "hoverClosestGl2d",
        "hoverClosestPie",
        "toggleHover",
        "toggleSpikelines",
        "resetViews"
        ]}
        fig.update_layout(showlegend=False)
        fig.write_html(myFile, config = config)
        html = myFile.getvalue()  
        self.webView_1.setHtml(html)
        print('ok plot1')

    def plots2(self):
        print('plot2 começou')
        if self.LongEdit.text() == '' or self.df is None:
            return
        df = self.df
        df = df.reset_index().rename(columns={'index': 'Date'})
        df['Date'] =  pd.to_datetime(df['Date'])
        df_aux = df.groupby([(df.Date.dt.year), (df.Date.dt.month)]).sum(numeric_only=True)[['PRECTOTCORR']]
        df = df.groupby([(df.Date.dt.year), (df.Date.dt.month)]).mean(numeric_only=True)[['T2M_MIN','T2M_MAX']]
        df['PRECTOTCORR'] = df_aux['PRECTOTCORR']
        df.reset_index(level=1, inplace=True)
        df = df.groupby(df.Date).mean()
        df.reset_index(inplace=True)
        df.rename(columns = {'Date':'Month'}, inplace = True)

        fig = make_subplots(specs=[[{"secondary_y": True}]])
        # Add traces
        fig.add_trace(
            go.Bar(x=df['Month'], y=df['PRECTOTCORR'], name='PRECTOTCORR'),
            secondary_y=False,
        )
        fig.add_trace(
            go.Line(x=df['Month'], y=df['T2M_MAX'], name='T2M_MAX'),
            secondary_y=True,
        )
        fig.update_layout(
            title_text="<b>Termopluviométrico</b>  (Long: "+self.LongEdit.text() + " Lat: "+self.LatEdit.text()+")"
        )

        # Set x-axis title
        fig.update_xaxes(title_text="Mês")

        fig.update_layout(
        xaxis = dict(
            tickmode = 'linear',
        )
        )

        # Set y-axes titles
        fig.update_yaxes(title_text="T2M_MAX (ºC)", secondary_y=True)
        fig.update_yaxes(title_text="PRECTOTCORR (mm)", secondary_y=False)

        myFile = io.StringIO()
        config = {'displaylogo': False,'modeBarButtonsToRemove': ['toImage','toggleHover']}
        fig.write_html(myFile, config = config)
        html = myFile.getvalue()  
        self.webView_4.setHtml(html)
        print('ok plot2')

    def plots3_compute(self):
        print('plot3 compute começou')
        if self.LongEdit.text() == '' or self.df is None:
            'plot 3 failed'
            return
        df = self.df
        df = df.reset_index().rename(columns={'index': 'Date'})
        df['Date'] =  pd.to_datetime(df['Date'])
        df_aux = df.copy()       
        df.set_index('Date', inplace=True)
        ds = df[['PRECTOTCORR', 'T2M_MAX', 'T2M_MIN']].copy().to_xarray()

        precip_indices = pdex.indices(time_dim='Date')
        temp_indices = tdex.indices(time_dim='Date')

        # Temperature Indices using 'T2M_MAX' and 'T2M_MIN'
        frost_days_df = temp_indices.annual_frost_days(ds, varname='T2M_MIN').to_dataframe()
        frost_days_df.columns = ['Annual Frost Days']
        # frost_days_df.to_csv(name +' - '+ 'Annual Frost Days.csv')

        tropical_nights_df = temp_indices.annual_tropical_nights(ds, varname='T2M_MIN').to_dataframe()
        tropical_nights_df.columns = ['Annual Tropical Nights']
        # tropical_nights_df.to_csv(name +' - '+ 'Annual Tropical Nights.csv')

        icing_days_df = temp_indices.annual_icing_days(ds, varname='T2M_MAX').to_dataframe()
        icing_days_df.columns = ['Annual Icing Days']
        # icing_days_df.to_csv(name +' - '+ 'Annual Icing Days.csv')

        summer_days_df = temp_indices.annual_summer_days(ds, varname='T2M_MAX').to_dataframe()
        summer_days_df.columns = ['Annual Summer Days']
        # summer_days_df.to_csv(name +' - '+ 'Annual Summer Days.csv')

        txx_df = temp_indices.monthly_txx(ds, varname='T2M_MAX').to_dataframe()[['T2M_MAX']]
        txx_df.columns = ['Monthly Maximum Temperature']
        # txx_df.to_csv(name +' - '+ 'Monthly Maximum Temperature.csv')

        txn_df = temp_indices.monthly_txn(ds, varname='T2M_MAX').to_dataframe()[['T2M_MAX']]
        txn_df.columns = ['Monthly Minimum Temperature of Maximum Temperatures']
        # txn_df.to_csv(name +' - '+ 'Monthly Minimum Temperature of Maximum Temperatures.csv')

        tnx_df = temp_indices.monthly_tnx(ds, varname='T2M_MIN').to_dataframe()[['T2M_MIN']]
        tnx_df.columns = ['Monthly Maximum Temperature of Minimum Temperatures']
        # tnx_df.to_csv(name +' - '+ 'Monthly Maximum Temperature of Minimum Temperatures.csv')

        tnn_df = temp_indices.monthly_tnn(ds, varname='T2M_MIN').to_dataframe()[['T2M_MIN']]
        tnn_df.columns = ['Monthly Minimum Temperature']
        # tnn_df.to_csv(name +' - '+ 'Monthly Minimum Temperature.csv')

        dtr_df = temp_indices.daily_temperature_range(ds, ds, min_varname='T2M_MIN', max_varname='T2M_MAX').to_dataframe(name="DTR")
        dtr_df.columns = ['Daily Temperature Range']
        # dtr_df.to_csv(name +' - '+ 'Daily Temperature Range.csv')
        rx1day_df = precip_indices.monthly_rx1day(ds, varname='PRECTOTCORR').to_dataframe()
        rx1day_df.columns = ['Monthly Maximum 1-day Precipitation']
        # rx1day_df.to_csv(name +' - '+ 'Monthly Maximum 1-day Precipitation.csv')

        rx5day_df = precip_indices.monthly_rx5day(ds, varname='PRECTOTCORR').to_dataframe()
        rx5day_df.columns = ['Monthly Maximum 5-day Precipitation']
        # rx5day_df.to_csv(name +' - '+ 'Monthly Maximum 5-day Precipitation.csv')

        r10mm_df = precip_indices.annual_r10mm(ds, varname='PRECTOTCORR').to_dataframe()
        r10mm_df.columns = ['Annual Count of Days when Precipitation Exceeds 10mm']
        # r10mm_df.to_csv(name +' - '+ 'Annual Count of Days when Precipitation Exceeds 10mm.csv')

        r20mm_df = precip_indices.annual_r20mm(ds, varname='PRECTOTCORR').to_dataframe()
        r20mm_df.columns = ['Annual Count of Days when Precipitation Exceeds 20mm']
        # r20mm_df.to_csv(name +' - '+ 'Annual Count of Days when Precipitation Exceeds 20mm.csv')

        prcptot_annual_df = precip_indices.prcptot(ds, period='1Y', varname='PRECTOTCORR').to_dataframe()
        prcptot_annual_df.columns = ['Total Annual Precipitation']
        # prcptot_annual_df.to_csv(name +' - '+ 'Total Annual Precipitation.csv')

        sdii_value_df = precip_indices.sdii(ds, period='1M', varname='PRECTOTCORR').to_dataframe()
        sdii_value_df.columns = ['Simple Precipitation Intensity Index']
        # sdii_value_df.to_csv(name +' - '+ 'Simple Precipitation Intensity Index.csv')

        cdd_value_df = precip_indices.cdd(ds, period='1M', varname='PRECTOTCORR').to_dataframe()
        cdd_value_df.columns = ['Number of Consecutive Dry Days in a Month']
        # cdd_value_df.to_csv(name +' - '+ 'Number of Consecutive Dry Days in a Month.csv')

        cwd_value_df = precip_indices.cwd(ds, period='1M', varname='PRECTOTCORR').to_dataframe()
        cwd_value_df.columns = ['Number of Consecutive Wet Days in a Month']

        df_aux['Accumulated_Precipitation'] = df_aux['PRECTOTCORR'].rolling(window=90).sum()
        df_aux.dropna(inplace=True)
        params = gamma.fit(df_aux['Accumulated_Precipitation'], floc=0)
        df_aux['Cumulative_Probability'] = gamma.cdf(df_aux['Accumulated_Precipitation'], *params)
        # Transform the cumulative probabilities to the standard normal distribution to get the SPI values
        df_aux['SPI'] = norm.ppf(df_aux['Cumulative_Probability'])
        # Display the first few rows with the accumulated precipitation and SPI values
        spi_value_df = df_aux[['SPI']].copy()
        spi_value_df.columns = ['The Standardized Precipitation Index (SPI)']

        print('ok plot3 compute')

        self.dataframes_dict = {
            'Annual Frost Days': frost_days_df,
            'Annual Tropical Nights': tropical_nights_df,
            'Annual Icing Days': icing_days_df,
            'Annual Summer Days': summer_days_df,
            'Monthly Maximum Temperature': txx_df,
            'Monthly Minimum Temperature of Maximum Temperatures': txn_df,
            'Monthly Maximum Temperature of Minimum Temperatures': tnx_df,
            'Monthly Minimum Temperature': tnn_df,
            'Daily Temperature Range': dtr_df,
            'Monthly Maximum 1-day Precipitation': rx1day_df,
            'Monthly Maximum 5-day Precipitation': rx5day_df,
            'Annual Count of Days when Precipitation Exceeds 10mm': r10mm_df,
            'Annual Count of Days when Precipitation Exceeds 20mm': r20mm_df,
            'Total Annual Precipitation': prcptot_annual_df,
            'Simple Precipitation Intensity Index': sdii_value_df,
            'Number of Consecutive Dry Days in a Month': cdd_value_df,
            'Number of Consecutive Wet Days in a Month': cwd_value_df,
            'The Standardized Precipitation Index (SPI)': spi_value_df,
        }
        print('ok plot3 compute')

    def plots3(self):
        print('plot3 começou')
        if self.atributo_2.currentText() == None or self.dataframes_dict is None:
            return
        df_plot = self.dataframes_dict[self.atributo_2.currentText()]
        print(self.atributo_2.currentText())
        myFile = io.StringIO()
        fig = px.line(df_plot, y=self.atributo_2.currentText(), title='<b>'+self.atributo_2.currentText()+'</b>  (Long: '+self.LongEdit.text() + ' Lat: '+self.LatEdit.text()+')')
        config = {'displaylogo': False,'modeBarButtonsToRemove': [
        "toImage",
        "sendDataToCloud",
        "zoom2d",
        "pan2d",
        "select2d",
        "lasso2d",
        "zoomIn2d",
        "zoomOut2d",
        "autoScale2d",
        "resetScale2d",
        "hoverClosestCartesian",
        "hoverCompareCartesian",
        "zoom3d",
        "pan3d",
        "orbitRotation",
        "tableRotation",
        "resetCameraLastSave",
        "resetCameraDefault3d",
        "hoverClosest3d",
        "zoomInGeo",
        "zoomOutGeo",
        "resetGeo",
        "hoverClosestGeo",
        "hoverClosestGl2d",
        "hoverClosestPie",
        "toggleHover",
        "toggleSpikelines",
        "resetViews"
        ]}
        fig.update_layout(showlegend=False)
        fig.write_html(myFile, config = config)
        html = myFile.getvalue()  
        self.webView_5.setHtml(html)
        print('ok plot3') 

    def actual_request_api(self):
        endtime = str(int(datetime.date.today().strftime("%Y"))-1)+'1231'
        base_url = (r"https://power.larc.nasa.gov/api/temporal/daily/point?parameters=T2M_MAX,PRECTOTCORR,T2M_MIN&community=RE&longitude={longitude}&latitude={latitude}&start=19810101&end="+endtime+"&format=JSON")
        api_request_url = base_url.format(longitude=float(self.LongEdit.text()), latitude = float(self.LatEdit.text()))
        response = requests.get(url=api_request_url, verify=True, timeout=1000)
        content = json.loads(response.content.decode('utf-8'))
        self.df = pd.DataFrame.from_dict(content['properties']['parameter'])
        print('ok request')       

    def request_api(self):
        QApplication.setOverrideCursor(Qt.WaitCursor)
        try:
            self.actual_request_api()
            self.plots1()
            self.tabWidget.setCurrentIndex(1)
            self.plots2()
            self.plots3_compute()
            self.plots3()
        
            QApplication.restoreOverrideCursor()
        except Exception as e:
            print(f"An error occurred: {e}")
            QApplication.restoreOverrideCursor()